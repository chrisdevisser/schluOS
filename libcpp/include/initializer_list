#pragma once

#include "detail/size_t.hh"

namespace std {

///initilializer_list - [support.initlist]
///Provides access to an array of const _T.
template<typename _T>
struct initializer_list {
    using value_type = _T;
    using const_reference = const _T&;
    using reference = const_reference;
    using size_type = size_t;
    using const_iterator = const _T*;
    using iterator = const_iterator;

    ///Constructs an empty initializer_list object.
    ///Post: size() == 0.
    constexpr initializer_list() noexcept
        : initializer_list{nullptr, 0} {}

    ///Returns: The number of elements in the array.
    ///Complexity: Constant time
    constexpr auto size() const noexcept {
        return len__;
    }

    ///Returns: A pointer to the beginning of the array.
    ///If size() == 0, begin() and end() are unspecified, but identical.
    constexpr auto begin() const noexcept {
        return array__;
    }

    ///Returns: begin() + size()
    constexpr auto end() const noexcept {
        return begin() + size();
    }

private:
    const_iterator array__; //points to the beginning of the array
    size_t len__; //the number of elements

    //Called by compiler
    constexpr initializer_list(const_iterator __array, size_type __len) noexcept
        : array__{__array}, len__{__len} {}
};

///Returns: __list.begin()
template<typename _T>
constexpr auto begin(initializer_list<_T> __list) noexcept {
    return __list.begin();
}

///Returns: __list.end()
template<typename _T>
constexpr auto end(initializer_list<_T> __list) noexcept {
    return __list.end();
}

}
