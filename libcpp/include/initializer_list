#pragma once

#include <detail/size_t.hh>
#include <detail/concepts/object.hh>

namespace std {

///initilializer_list - [support.initlist]
///Provides access to an array of const _T.
template<Object _T>
struct initializer_list {
    using value_type = _T;
    using const_reference = const _T&;
    using reference = const_reference;
    using size_type = size_t;
    using const_iterator = const _T*;
    using iterator = const_iterator;

    ///Constructs an empty initializer_list object.
    ///Post: size() == 0.
    constexpr initializer_list() noexcept
        : array__{}, len__{} {}

    ///Returns: The number of elements in the array.
    ///Complexity: Constant time
    constexpr auto size() const noexcept {
        return len__;
    }

    ///Returns: A pointer to the beginning of the array.
    ///If size() == 0, begin() and end() are unspecified, but identical.
    constexpr auto begin() const noexcept {
        return array__;
    }

    ///Returns: begin() + size()
    constexpr auto end() const noexcept {
        return begin() + size();
    }

private:
    const_iterator array__; //required by GCC: points to the beginning of the array
    size_t len__; //required by GCC: the number of elements
};

///Returns: __list.begin()
template<Object _T>
constexpr auto begin(initializer_list<_T> __list) noexcept {
    return __list.begin();
}

///Returns: __list.end()
template<Object _T>
constexpr auto end(initializer_list<_T> __list) noexcept {
    return __list.end();
}

}
